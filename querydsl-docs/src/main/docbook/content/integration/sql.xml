<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<sect1 id="sql_integration" revision="1">
  
  <title>Querying SQL/JDBC sources</title>
  
  <para>This chapter describes the query type generation and querying functionality of the SQL module.</para>
  
  <sect2>
  
    <title>Creating the Querydsl query types</title>
  
  <para>To get started export your schema into Querydsl query types like this :</para>
  
<programlisting language="java"><![CDATA[  
java.sql.Connection conn; // connection of database containing the schema to use
// obtain Connection etc.

NamingStrategy namingStrategy = new DefaultNamingStrategy();
MetaDataSerializer serializer = new MetaDataSerializer("Q",namingStrategy);            
MetaDataExporter exporter = new MetaDataExporter(
    "Q",                       // namePrefix 
    "com.myproject.mydomain",  // target package  
    new File("src/main/java"), // target source folder
    namingStrategy,            // naming strategy
    serializer);               // serializer
exporter.export(conn.getMetaData());  
]]></programlisting>

  <para>This declares that the database schema is to be mirrored into the com.myproject.domain package in the src/main/java folder.</para>
  
  <para>
  The generated types have the table name transformed to mixed case as the class name and a similar mixed case transformation
  applied to the columns which are available as property paths in the query type.
  </para>
 
  <para>
  In addition to this primary key and foreign key constraints are provided as fields which can be used for compact join declarations ... TODO 
  </para>
  
 </sect2>
 
 <sect2>
 
  <title>Maven integration</title> 
    
  <para>This functionality is also available as a Maven plugin. The presented example can be declared like this in the POM :</para>
  
<programlisting language="xml"><![CDATA[   
<plugin>
  <groupId>com.mysema.querydsl</groupId>
  <artifactId>querydsl-maven-plugin</artifactId>
  <version>${querydsl.version}</version>
  <executions>
    <execution>
      <goals>
        <goal>export</goal>
      </goals>
    </execution>            
  </executions>
  <configuration>
    <jdbcDriver>org.apache.derby.jdbc.EmbeddedDriver</jdbcDriver>
    <jdbcUrl>jdbc:derby:target/demoDB;create=true</jdbcUrl>
    <!--
      optional elements :
      * namePrefix
      * jdbcUser
      * jdbcPassword
      * schemaPattern
      * tableNamePattern    
    -->    
    <packageName>com.myproject.domain</packageName>
    <targetFolder>target/generated-sources/java</targetFolder>
  </configuration>
  <dependencies>
    <dependency>
      <groupId>org.apache.derby</groupId>
      <artifactId>derby</artifactId>
      <version>${derby.version}</version>
    </dependency>
  </dependencies>
</plugin>  
]]></programlisting>  

  <para>Use the goal <emphasis>test-export</emphasis> to add the targetFolder as a test compile source root
  instead of a compile source root.</para>
  
  </sect2>
  
  <sect2>
  
    <title>Querying</title>
  
    <para>Querying with Querydsl SQL is as simple as this :</para>
    
<programlisting language="java"><![CDATA[ 
QCustomer customer = new QCustomer("c");

SQLTemplates dialect = new HSQLDBTemplates(); // SQL-dialect
SQLQuery query = SQLQueryImpl(connection, dialect); 
List<String> lastNames = query.from(customer)
    .where(customer.firstName.eq("Bob"))
    .list(customer.lastName);
]]></programlisting>  

    <para>which is transformed into the following sql query, assuming that the related table name is 
    <emphasis>customer</emphasis> and the columns <emphasis>first_name</emphasis> and 
    <emphasis>last_name</emphasis> :</para>
    
<programlisting><![CDATA[     
SELECT c.last_name 
FROM customer c 
WHERE c.first_name = 'Bob'
]]></programlisting>  

    <para>Internally Querydsl SQL uses PreparedStatements, though.</para>

    <para>Querydsl uses SQL dialects to customize the SQL serialization needed for different relational databases. The
    available dialects are :</para>
    
    <itemizedlist>
      <listitem>
        <para>com.mysema.query.sql.DerbyTemplates</para>
        <itemizedlist>
          <listitem><para>tested with version 10.5.3</para></listitem>
        </itemizedlist>        
      </listitem>
      <listitem>
        <para>com.mysema.query.sql.HSQLDBTemplates</para>
        <itemizedlist>
          <listitem><para>tested with version 1.8.0.7</para></listitem>
        </itemizedlist>        
      </listitem>
	<listitem>
        <para>com.mysema.query.sql.H2Templates</para>
        <itemizedlist>
          <listitem><para>tested with H2 1.2.133</para></listitem>
        </itemizedlist>
      </listitem>      
      <listitem>
        <para>com.mysema.query.sql.MySQLTemplates</para>
        <itemizedlist>
          <listitem><para>tested with MySQL CE 5.1</para></listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>com.mysema.query.sql.OracleTemplates</para>
        <itemizedlist>
          <listitem><para>tested with Oracle 10g XE</para></listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>com.mysema.query.sql.PostgresTemplates</para>
        <itemizedlist>
          <listitem><para>tested with Postgres 8.4</para></listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>com.mysema.query.sql.SQLServerTemplates</para>
        <itemizedlist>
          <listitem><para>tested with SQL Server 2008</para></listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
    
  </sect2>
  
  <sect2>

  <title>General usage</title>
  
  <para>Use the the cascading methods of the SQLQuery interface like this</para>
  
  <para><emphasis>from :</emphasis> Define the query sources here.</para>
  
  <para><emphasis>innerJoin, join, leftJoin, fullJoin, on</emphasis> : Define join elements using these constructs. 
  For the join methods the first argument is the join source and the second the target (alias).</para>
  
  <para><emphasis>where :</emphasis> Define the query filters, either in varargs form separated via commas or 
  cascaded via the and-operator.</para>
  
  <para><emphasis>groupBy :</emphasis> Define the group by arguments in varargs form.</para>
  
  <para><emphasis>having :</emphasis> Define the having filter of the "group by" grouping as an varags array of 
  EBoolean expressions.</para>
  
  <para><emphasis>orderBy :</emphasis> Define the ordering of the result as an varargs array of order expressions. 
  Use asc() and desc() on numeric, string and other comparable expression to access the OrderSpecifier instances. </para>
  
  <para><emphasis>limit, offset, restrict :</emphasis> Define the paging of the result. Limit for max results, 
  offset for skipping rows and restrict for defining both in one call.</para>
  
  </sect2>  
  
  <sect2>
  
  <title>Ordering</title>
  
  <para>The syntax for declaring ordering is </para>
  
<programlisting language="java"><![CDATA[ 
query.from(customer)
    .orderBy(customer.lastName.asc(), customer.firstName.asc())
    .list(customer.firstName, customer.lastName);
]]></programlisting>

  <para>which is equivalent to the following native SQL</para>  

<programlisting>  
SELECT c.first_name, c.last_name
FROM customer c 
ORDER BY c.last_name ASC, c.first_name ASC
</programlisting>
  
  </sect2>  

  <sect2>
  
  <title>Grouping</title>
  
  <para>Grouping can be done in the following form</para>
  
<programlisting language="java"><![CDATA[ 
query.from(customer)
    .groupBy(customer.lastName)
    .list(customer.lastName);
]]></programlisting>

  <para>which is equivalent to the following native SQL</para>  

<programlisting>  
SELECT c.last_name 
FROM customer c 
GROUP BY c.last_name
</programlisting>
      
  </sect2>    
  
  <sect2>
  
    <title>Union queries</title>
    
    <para>TODO</para>
  
  </sect2>
  
  <sect2>
  
    <title>Query extension support</title>
    
    <para>TODO</para>
  
  </sect2>
  
  <sect2>
  
    <title>Using DDL commands</title>
    
    <para>TODO</para>
  
  </sect2>
  
  <sect2>
  
    <title>Using Data manipulation commands</title>
    
    <para>Insert examples :</para>
    
<programlisting language="java"><![CDATA[    
// with columns
insert(survey)
    .columns(survey.id, survey.name)
    .values(3, "Hello").execute();

// without columns
insert(survey)
    .values(4, "Hello").execute();

// with subquery
insert(survey)
    .columns(survey.id, survey.name)
    .select(s().from(survey2).list(survey2.id.add(1), survey2.name))
    .execute();

// with subquery, without columns
insert(survey)
    .select(s().from(survey2).list(survey2.id.add(10), survey2.name))
    .execute();
]]></programlisting>

  <para>Using the following methods :</para>

<programlisting language="java"><![CDATA[    
    protected SQLInsertClause insert(PEntity<?> e){
        return new SQLInsertClause(getConnection(), dialect, e);
    }   
    
    protected SQLSubQuery s(){
        return new SQLSubQuery();
    }    
]]></programlisting>    

   <para>Update examples :</para> 
  
<programlisting language="java"><![CDATA[  
// update with where
update(survey).where(survey.name.eq("XXX")).set(survey.name, "S").execute();
  
// update without where
update(survey).set(survey.name, "S").execute()  
]]></programlisting>

  <para>Using the following methods :</para>
  
<programlisting language="java"><![CDATA[  
    protected SQLUpdateClause update(PEntity<?> e){
        return new SQLUpdateClause(Connections.getConnection(), dialect, e);
    }
]]></programlisting>
  
  </sect2>
  
  <sect2>
  
    <title>User types</title>
    
    <para>TODO</para>
    
  </sect2>
  
</sect1>    