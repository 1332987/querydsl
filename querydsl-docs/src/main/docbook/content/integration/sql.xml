<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<sect1 id="sql_integration" revision="1">
  
  <title>Querying SQL/JDBC sources</title>
  
  <para>The querydsl-sql module is still in Beta stage and hasn't been tested much, but it is functional and usable.</para>
  
  <para>This chapter describes the query type generation and querying functionality of the module.</para>
  
  <sect2>
  
    <title>Creating the Querydsl query types</title>
  
  <para>To get started export your schema into Querydsl query types like this :</para>
  
<programlisting language="java"><![CDATA[  
java.sql.Connection conn; // connection of database containing the schema to use
MetaDataExporter exporter = new MetaDataExporter("Q", "com.myproject.domain", null, null, "src/main/java");
exporter.export(conn.getMetaData());
]]></programlisting>

  <para>This declares that the database schema is to be mirrored into the com.myproject.domain package in the src/main/java folder.</para>
  
  <para>This functionality might get packaged into an Maven plugin in the future.</para>
  
  <para>The generated types have the table name transformed to mixed case as the class name and a similar mixed case transformation
  applied to the columns which are available as property paths in the query type.</para>

  </sect2>
  
  <sect2>
  
    <title>Querying</title>
  
    <para>Querying with Querydsl SQL is as simple as this :</para>
    
<programlisting language="java"><![CDATA[ 
QCustomer customer = new QCustomer("c");

SQLTemplates dialect = new HSQLDBTemplates(); // SQL-dialect
SQLQuery query = SQLQueryImpl(connection, dialect); 
List<String> lastNames = query.from(customer)
    .where(customer.firstName.eq("Bob"))
    .list(customer.lastName);
]]></programlisting>  

    <para>which is transformed into the following sql query, assuming that the related table name is 
    <emphasis>customer</emphasis> and the columns <emphasis>first_name</emphasis> and 
    <emphasis>last_name</emphasis> :</para>
    
<programlisting><![CDATA[     
SELECT c.last_name 
FROM customer c 
WHERE c.first_name = 'Bob'
]]></programlisting>  

    <para>Internally Querydsl SQL uses PreparedStatements, though.</para>

    <para>Querydsl uses SQL dialects to customize the SQL serialization needed for different relational databases. The
    available dialects are <emphasis>DerbyTemplates</emphasis>, <emphasis>HSQLDBTemplates</emphasis>, 
    <emphasis>MySQLTemplates</emphasis> and <emphasis>OracleTemplates</emphasis>.</para>
    
  </sect2>
  
  <sect2>

  <title>General usage</title>
  
  <para>Use the the cascading methods of the SQLQuery method like this</para>
  
  <para><emphasis>from :</emphasis> Define the query sources here.</para>
  
  <para><emphasis>innerJoin, join, leftJoin, fullJoin, on</emphasis> : Define join elements using these constructs. 
  For the join methods the first argument is the join source and the second the target (alias).</para>
  
  <para><emphasis>where :</emphasis> Define the query filters, either in varargs form separated via commas or 
  cascaded via the and-operator.</para>
  
  <para><emphasis>groupBy :</emphasis> Define the group by arguments in varargs form.</para>
  
  <para><emphasis>having :</emphasis> Define the having filter of the "group by" grouping as an varags array of 
  EBoolean expressions.</para>
  
  <para><emphasis>orderBy :</emphasis> Define the ordering of the result as an varargs array of order expressions. 
  Use asc() and desc() on numeric, string and other comparable expression to access the OrderSpecifier instances. </para>
  
  <para><emphasis>limit, offset, restrict :</emphasis> Define the paging of the result. Limit for max results, 
  offset for skipping rows and restrict for defining both in one call.</para>
  
  </sect2>  
  
  <sect2>
  
  <title>Ordering</title>
  
  <para>The syntax for declaring ordering is </para>
  
<programlisting language="java"><![CDATA[ 
query.from(customer)
    .orderBy(customer.lastName.asc(), customer.firstName.asc())
    .list(customer.firstName, customer.lastName);
]]></programlisting>

  <para>which is equivalent to the following native SQL</para>  

<programlisting>  
SELECT c.first_name, c.last_name
FROM customer c 
ORDER BY c.last_name ASC, c.first_name ASC
</programlisting>
  
  </sect2>  

  <sect2>
  
  <title>Grouping</title>
  
  <para>Grouping can be done in the following form</para>
  
<programlisting language="java"><![CDATA[ 
query.from(customer)
    .groupBy(customer.lastName)
    .list(customer.lastName);
]]></programlisting>

  <para>which is equivalent to the following native SQL</para>  

<programlisting>  
SELECT customer.last_name 
FROM customer c 
GROUP BY c.last_name
</programlisting>
      
  </sect2>    
  
  <sect2>
  
    <title>Using Data manipulation commands</title>
    
    <para>TODO</para>
  
  </sect2>
  
</sect1>    