<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="general" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>General usage</title>
    
<sect1>
    
    <title>Best practices</title>
    
    <sect2>
  
    <title>Use default variable of the Query types</title>
    
    <para>Use the default variables of the query types as much as possible. The default variables
    are available as static final fields in the query types. The name is always the decapitalized version
    of the simple type name. For the type Account this would be account :</para>
    
<programlisting language="java"><![CDATA[     
public class QAccount extends PEntity<Account>{
      
    public static final QAccount account = new QAccount("account");
    
}
]]></programlisting>      

  <para>
  Querydsl query types are safe to re-use, and by using Querydsl default variables you save initialization time
  and memory.
  </para>
    
  </sect2>
 
  <sect2>
  
    <title>Interface based usage</title>
  
    <para>Whenever possible, use interface based query references : e.g. JDOQLQuery for JDO and HQLQuery for HQL</para>
  
  </sect2>
  
  <sect2>
  
    <title>Custom query extensions</title>
  
    <para>TODO</para>
  
  </sect2>
 
  <sect2 id="dao_integration">
  
  <title>DAO integration</title>
  
  <para>A practice which we have found to be very easy to use is to provide factory methods for 
  Query instances in DAO implementations in the following form.</para>
  
  <para>For HQL usage :</para>
  
<programlisting language="java"><![CDATA[ 
protected HQLQuery from(PEntity<?>... o) {
    return new HqlQueryImpl(session).from(o);
} 
]]></programlisting>  
  
  <para>For JDO usage : </para>
  
<programlisting language="java"><![CDATA[
protected JDOQLQuery from(PEntity<?>... o) {
    return new JDOQLQueryImpl(persistenceManager).from(o);
}        
]]></programlisting>         
  
  </sect2>        
  
  </sect1>    
    
<sect1>
    
    <title>Special expressions</title>
    
    <sect2>
      <title>Constructor projections</title>
      
      <para>
      Querydsl provides the possibility to use constructor invocations in projections.
      To use a constructor in a query projection, you need to annotate it with the QueryProjection
      annotation :
      </para>
      
<programlisting language="java"><![CDATA[
class CustomerDTO {

  @QueryProjection
  public CustomerDTO(long id, String name){
     ...
  }

}
]]></programlisting>    

    <para>And then you can use it like this in the query</para>


<programlisting language="java"><![CDATA[
QCustomer customer = QCustomer.customer;
HQLQuery query = new HibernateQuery(session);
List<CustomerDTO> dtos = qry.from(customer).list(new QCustomerDTO(customer.id, customer.name));     
]]></programlisting>     

      <para>While the example is Hibernate specific, this feature is present in all modules.</para>
      
      <para>If the type with the QueryProjection annotation is not an annotated entity type, you can
      use the constructor projection like in the example, but if the annotated type would be an entity type, then
      the constructor projection would need to be created via a call to the static create method of the query type :
      </para>
      
<programlisting language="java"><![CDATA[
@Entity
class Customer {

  @QueryProjection
  public Customer(long id, String name){
     ...
  }

}
]]></programlisting>         

<programlisting language="java"><![CDATA[
QCustomer customer = QCustomer.customer;
HQLQuery query = new HibernateQuery(session);
List<Customer> dtos = qry.from(customer).list(new QCustomer.create(customer.id, customer.name));   
]]></programlisting>   
    
    <para>Alternatively, if code generation is not an option, you can create a constructor projection like this :</para>
    
<programlisting language="java"><![CDATA[
List<Customer> dtos = qry.from(customer)
    .list(EConstructor.create(Customer.class, customer.id, customer.name));   
]]></programlisting>       
    
    </sect2>
    
    <sect2>
      <title>Complex boolean expressions</title>
    
    <para>
    To construct complex boolean expressions, use the BooleanBuilder class. 
    It extends EBoolean and can be used in cascaded form : 
    </para>
    
    <programlisting language="java"><![CDATA[
public List<Customer> getCustomer(String... names){
    QCustomer customer = QCustomer.customer;    
    HibernateQuery qry = new HibernateQuery(session).from(customer);    
    BooleanBuilder builder = new BoolenBuilder();
    for (String name : names){
        builder.or(customer.name.eq(name));
    }
    qry.where(builder); // customer.name eq name1 OR customer.name eq name2 OR ...  
    return qry.list(customer);
}
]]></programlisting>    
    
    </sect2>
    
    <sect2>
      <title>Case expressions</title>
      
    <para>To construct case-when-then-else expressions use the CaseBuilder class like this : </para>  
    
<programlisting language="java"><![CDATA[    
QCustomer customer = QCustomer.customer;    
Expr<String> cases = new CaseBuilder()
    .when(customer.annualSpending.gt(10000)).then("Premier")
    .when(customer.annualSpending.gt(5000)).then("Gold")
    .when(customer.annualSpending.gt(2000)).then("Silver")
    .otherwise("Bronze");
// The cases expression can now be used in a projection or condition        
]]></programlisting>     
    
    <para>For case expressions with equals-operations use the following simpler form instead :</para>
    
<programlisting language="java"><![CDATA[    
QCustomer customer = QCustomer.customer;    
Expr<String> cases = customer.annualSpending
    .when(10000).then("Premier")
    .when(5000).then("Gold")
    .when(2000).then("Silver")
    .otherwise("Bronze");
// The cases expression can now be used in a projection or condition        
]]></programlisting>         
      
    <para>Case expressions are not yet supported in JDOQL.</para>  
      
    </sect2>
    
    </sect1>    
    
    <sect1>
      <title>Customizations</title>
      
    <sect2>
      <title>Path initialization</title>
    
      <para>
      By default Querydsl initializes only direct reference properties. In cases where longer initialization paths
      are required, these have to be annotated in the domain types via com.mysema.query.annotations.QueryInit usage.
      QueryInit is used on properties where deep initializations are needed. The following example demonstrates the
      usage.       
      </para>
      
      <programlisting language="java"><![CDATA[
@Entity      
class Event {
    @QueryInit("customer")
    Account account;
}      

@Entity
class Account{
    Customer customer;    
}

@Entity
class Customer{
    String name;
    // ...
}
]]></programlisting>      
    
    <para>
    This example enforces the initialization of the account.customer path, when an Event path is initialized
    as a root path / variable. The path initialization format supports wildcards as well, e.g. "customer.*" or just "*".
    </para>
    
    <para>
    The declarative path initialization replaces the manual one, which required the entity fields to be non-final. The
    declarative format has the benefit to be applied to all top level instances of a Query type and to enable the usage
    of final entity fields. 
    </para>
    
    <para>
    Declarative path initialization is the preferred initialization strategy, but manual initialization can be activated
    via the QuerydslConfig annotation, which is described below.
    </para>
    
    </sect2>
    
    <sect2>
      <title>Customization of serialization</title>
      
      <para>
      The serialization of Querydsl can be customized via QuerydslConfig annotations on packages and types. They customize the 
      serialization of the annotated package or type.
      </para>
      
      <para>
      The serialization options are 
      <emphasis>entityAccessors</emphasis> to generate accessor methods for entity paths instead of public final fields (default : false)), 
      <emphasis>listAccessors</emphasis> to generate listProperty(int index) style methods (default : false), 
      <emphasis>mapAccessors</emphasis> to generate mapProperty(Key key) style accessor methods (default : false) and
	  <emphasis>createDefaultVariable</emphasis> to generate the default variable (default : true).
      </para>
	  
	  <para>Examples</para>
	  
	  <para>Customization of Entity type serialization</para>
	  
	  <programlisting language="java"><![CDATA[
@QuerydslConfig(entityAccessors=true)
@Entity
public class UserÂ {
	//...
}  	  
]]></programlisting>

    <para>Customization of package content</para>
	
     <programlisting language="java"><![CDATA[
@QuerydslConfig(listAccessors=true)
package com.mysema.query.domain.rel;

import com.mysema.query.annotations.QuerydslConfig;
]]></programlisting>

    <para>
    If you want to customize the serializer configuration globally, you can do this via the APT options 
	<emphasis>querydsl.entityAccessors</emphasis>, 
	<emphasis>querydsl.listAccessors</emphasis>, 
	<emphasis>querydsl.mapAccessors</emphasis> and
	<emphasis>querydsl.createDefaultVariable</emphasis>.
	</para>
    
	<para>Using the Maven APT plugin this works for example like this : </para>
	
    <programlisting language="xml"><![CDATA[
<project>
  <build>
  <plugins>
    ...
    <plugin>
      <groupId>com.mysema.maven</groupId>
      <artifactId>maven-apt-plugin</artifactId>
      <version>0.3.2</version>
      <executions>
        <execution>
          <goals>
            <goal>process</goal>
          </goals>
          <configuration>
            <outputDirectory>target/generated-sources/java</outputDirectory>
            <processor>com.mysema.query.apt.jpa.JPAAnnotationProcessor</processor>
            <options>
              <querydsl.entityAccessors>true</querydsl.entityAccessors>
            </options>			
          </configuration>
        </execution>
      </executions>
    </plugin>
    ...
  </plugins>
  </build>
</project>
]]></programlisting>	
	
	
    </sect2>
    
    <sect2 id="custom_types">
      <title>Custom type mappings</title>
      
      <para>
      Custom type mappings can be used on properties to override the derived Path type. This can be useful for example in cases where
      comparison and String operations should be blocked on certain String paths or Date / Time support for custom
      types needs to be added. Support for Date / Time types of the Joda time API and JDK (java.util.Date, Calendar and subtypes) 
      is built in, but other APIs might need to be supported using this feature.
      </para>
      
      <para>The following example demonstrates the usage :</para>
      
      <programlisting language="java"><![CDATA[
@Entity      
public class MyEntity{      
    @QueryType(PropertyType.SIMPLE)
    public String stringAsSimple;
        
    @QueryType(PropertyType.COMPARABLE)
    public String stringAsComparable;
        
    @QueryType(PropertyType.NONE)
    public String stringNotInQuerydsl;    
}        
]]></programlisting>          
    
      <para>The value PropertyType.NONE can be used to skip a property in the Querydsl query type generation. This case is different
      from @Transient or @QueryTransient annotated properties, where properties are not persisted. PropertyType.NONE just omits the
      property from the Querydsl query type.</para>
    
    </sect2>      

    <sect2>
    <title>Custom methods in query types</title>
  
    <para>
    Querydsl provides the possibility to annotate methods for mirroring in query types. Methods can either be annotated 
    directly in the context of the class where they belong or in query extension interfaces, if the target class is only available for
    annotation.
    </para>
  
    <para>Example 1</para>
    
<programlisting language="java"><![CDATA[    
public class Point{
  // ...   
}

@QueryExtensions(Point.class)
public interface PointOperations {

   @QueryMethod("geo_distance({0}, {1})")
   int geoDistance(Point otherPoint);

}    
]]></programlisting>

    <para>The first example describes indirect annotation via QueryExtensions usage. Let's assume that Point is a class of
    an external library which has to be used as such without the possibility of customization in source form.</para>
    
    <para>To make a geoDistance(Point) method available in the Querydsl query type for Point, a query extension interface is used.
    Via the QueryExtensions annotation the interface is bound to the Point class and via the QueryMethod annotation the geoDistance method
    is declared to be mirrored into the Point query type with a serialization pattern of "geo_distance({0}, {1})".</para>
    
    <para>The serialization patterns of query methods have the host object itself always as the first argument and the method parameters
    as further arguments.</para>
    
    <para>Example 2</para>
    
<programlisting language="java"><![CDATA[
public class Point{

    @QueryMethod("geo_distance({0}, {1})")
    int geoDistance(Point otherPoint){
       // dummy implementation
        return 0;
    }
   
}
]]></programlisting>    

  <para>The second example features the same use case as in the first example, but this time the Point class is annotated directly.
  This approach is feasible, if the related domain type is available for annotation and APT post processing.</para>
  
    </sect2>    
	
	<sect2>
		<title>Delegate methods</title>
		
	<para>Instead of custom methods with serialization templates, static delegates can be used.</para>
	
	<para>Here is a simple example from a unit test: </para>
	
<programlisting language="java"><![CDATA[   
    @QueryEntity
    public static class User{
       
        String name;
       
        User managedBy;
       
    }
   
    @QueryDelegate(User.class)
    public static EBoolean isManagedBy(QUser user, User other){
        // TODO : create complex expression here and return it
        return EBooleanConst.TRUE;
    }
   
    @QueryDelegate(User.class)
    public static EBoolean isManagedBy(QUser user, QUser other){
        // TODO : create complex expression here and return it
        return EBooleanConst.TRUE;
    }
   
    @QueryDelegate(User.class)
    public static EBoolean simpleMethod(QUser user){
        // TODO : create complex expression here and return it
        return EBooleanConst.TRUE;
    }
   
    @QueryDelegate(User.class)
    public static PString getName(QUser user){
        return user.name;
    }
]]></programlisting>    	


	<para>And the generated methods in the query type :</para>

<programlisting language="java"><![CDATA[   
    public EBoolean isManagedBy(Qser other) {
        return com.mysema.query.domain.DelegateTest.isManagedBy(this, other);
    }

    public EBoolean isManagedBy(User other) {
        return com.mysema.query.domain.DelegateTest.isManagedBy(this, other);
    }

    public PString getName() {
        return com.mysema.query.domain.DelegateTest.getName(this);
    }

    public EBoolean simpleMethod() {
        return com.mysema.query.domain.DelegateTest.simpleMethod(this);
    }	
]]></programlisting>    		
		
	</sect2>
    
    </sect1>

<!-- INHERITANCE -->    
    
    <sect1 id="type_inheritance">
    
      <title>Inheritance in Querydsl types</title>
      
      <para>
      To avoid a generic signature in Querydsl query types the type hierarchies are flattened. The result is that
      all generated query types are direct subclasses of com.mysema.query.types.path.PEntity and cannot be directly cast
      to their Querydsl supertypes.
      </para>
      
      <para>
      Instead of a direct Java cast, the supertype reference is accessible via the _super field. A _super-field is available
      in all query types with a single supertype :
      </para>
      
      <programlisting language="java"><![CDATA[
// from Account
QAccount extends PEntity<Account>{
    // ...
}

// from BankAccount extends Account
QBankAccount extends PEntity<BankAccount>{

    public final QAccount _super = new QAccount(this);
    
    // ...
}            
]]></programlisting>      
    
    <para>To cast from a supertype to a subtype you can use the as-method of the PEntity class :</para>
    
    <programlisting language="java"><![CDATA[
QAccount account = new QAccount("account");
QBankAccount bankAccount = account.as(QBankAccount.class);    
]]></programlisting>    
    
    </sect1>
    
<!-- ALIAS USAGE -->    
    
    <sect1 id="alias">
    
  <title>Alias usage</title>

  <para>
    In cases where code generation is not an option, alias objects
    can be used as path references for expression construction.
  </para>

  <para>
    The following examples demonstrate how alias objects can be used
    as replacements for expressions based on generated types.
  </para>

  <para>
    At first an example query with APT generated domain types :
  </para>

  <programlisting language="java">
QCat cat = new QCat("cat");
for (String name : from(cat,cats)
  .where(cat.kittens.size().gt(0))
  .iterate(cat.name)){
    System.out.println(name);
}
  </programlisting>

  <para>
    And now with an alias instance for the Cat class. The call
    "c.getKittens()" inside the dollar-method is internally transformed
    into the property path c.kittens.
  </para>

  <programlisting language="java">
Cat c = alias(Cat.class, "cat");
for (String name : from($(c),cats)
  .where($(c.getKittens()).size().gt(0))
  .iterate($(c.getName()))){
    System.out.println(name);
}
  </programlisting>

  <para>
    To use the alias functionality in your code, add the following two
    imports
  </para>

  <programlisting language="java">
import static com.mysema.query.alias.Alias.$;
import static com.mysema.query.alias.Alias.alias;
  </programlisting>

  <para>
    The following example is a variation of the previous, where the access to
    the list size happens inside the dollar-method invocation.
  </para>

  <programlisting language="java">
Cat c = alias(Cat.class, "cat");
for (String name : from($(c),cats)
  .where($(c.getKittens().size()).gt(0))
  .iterate($(c.getName()))){
    System.out.println(name);
}
  </programlisting>

  <para>
    All non-primitive and non-String typed properties of aliases are aliases
    themselves. So you may cascade method calls until you hit a
    primitive or String type in the dollar-method scope.
    e.g.
  </para>

  <programlisting language="java">
$(c.getMate().getName())
  </programlisting>

  <para>
    is transformed into *c.mate.name* internally, but
  </para>

  <programlisting language="java">
$(c.getMate().getName().toLowerCase())
  </programlisting>

  <para>
    is not transformed properly, since the toLowerCase() invocation is not
    tracked.
  </para>

  <para>
    Note also that you may only invoke getters, size(), contains(Object) and
    get(int) on alias types. All other invocations throw exceptions.
  </para>
        
  </sect1>
  
  <sect1>
    <title>Dynamic path usage</title>
    
    <para>
    For dynamic path generation the PathBuilder class can be used. It extends PEntity and can be used
    as an alternative to class generation and alias-usage for path generation. 
    </para>
    
    <para>String property :</para>
    
<programlisting language="java">
PathBuilder&lt;User&gt; entityPath = new PathBuilder&lt;User&gt;(User.class, "entity");
// fully generic access
entityPath.get("userName");
// .. or with supplied type
entityPath.get("userName", String.class);
// .. and correct signature
entityPath.getString("userName").lower();
</programlisting>

    <para>List property : </para>

<programlisting language="java">
entityPath.getList("list", String.class, PString.class).get(0).lower();
entityPath.getList("list", String.class).get(0);
</programlisting>

    <para>Map property : </para>

<programlisting language="java">
entityPath.getMap("map", String.class, String.class, PString.class).get("key").lower();
entityPath.getMap("map", String.class, String.class).get("key");
</programlisting>
      
  </sect1>
                   
</chapter>    