<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="advanced" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Advanced usage</title>
    
<sect1>
    
    <title>Best practices</title>
    
    <sect2>
  
    <title>Use default variable of the Query types</title>
    
    <para>Use the default variables of the query types as much as possible. The default variables
    are available as static final fields in the query types. The name is always the decaptialized version
    of the simple type name. For the type Account this would be account :</para>
    
<programlisting language="java"><![CDATA[     
QAccount extends PEntity<Account>{
      
    public static final Account account = new QAccount("account");
}
]]></programlisting>      

  <para>
  Querydsl query types are safe to re-use, and by using Querydsl default variables you save initialization time
  and memory.
  </para>
    
  </sect2>
 
  <sect2>
  
    <title>Interface based usage</title>
  
    <para>Whenever possible, use interface based query references : JDOQLQuery for JDO and HQLQuery for HQL</para>
  
  </sect2>
  
  <sect2>
  
    <title>Custom query extensions</title>
  
    <para>TODO</para>
  
  </sect2>
 
  <sect2 id="dao_integration">
  
  <title>DAO integration</title>
  
  <para>A practice which we have found to be very easy to use is to provide factory methods for 
  Query instances in DAO implementations in the following form.</para>
  
  <para>For HQL usage :</para>
  
<programlisting language="java"><![CDATA[ 
protected HQLQuery from(PEntity<?>... o) {
    return new HqlQueryImpl(session).from(o);
} 
]]></programlisting>  
  
  <para>For JDO usage : </para>
  
<programlisting language="java"><![CDATA[
protected JDOQLQuery from(PEntity<?>... o) {
    return new JDOQLQueryImpl(persistenceManager).from(o);
}        
]]></programlisting>         
  
  </sect2>        
  
  </sect1>    
    
<sect1>
    
    <title>Special expressions</title>
    
    <sect2>
      <title>Constructor projections</title>
      
      <para>
      Querydsl provides the possibility to use constructor invocations in projections.
      To use a constructor in a query projection, you need to annotate it with the QueryProjection
      annotation :
      </para>
      
<programlisting language="java"><![CDATA[
class CustomerDTO {

  @QueryProjection
  public CustomerDTO(long id, String name){
     ...
  }

}
]]></programlisting>    

    <para>And then you can use it like this in the query</para>


<programlisting language="java"><![CDATA[
QCustomer customer = QCustomer.customer;
HQLQuery query = new HibernateQuery(session);
List<CustomerDTO> dtos = qry.from(customer).list(new QCustomerDTO(customer.id, customer.name));     
]]></programlisting>     

      <para>While the example is Hibernate specific, this feature is present in all modules.</para>
      
      <para>If the type with the QueryProjection annotation is not an annotated entity type, you can
      use the constructor projection like in the example, but if the annotated type would be an entity type, then
      the constructor projection would need to be created via a call to the static create method of the query type :
      </para>
      
<programlisting language="java"><![CDATA[
@Entity
class Customer {

  @QueryProjection
  public Customer(long id, String name){
     ...
  }

}
]]></programlisting>         

<programlisting language="java"><![CDATA[
QCustomer customer = QCustomer.customer;
HQLQuery query = new HibernateQuery(session);
List<Customer> dtos = qry.from(customer).list(new QCustomer.create(customer.id, customer.name));   
]]></programlisting>   
    
    </sect2>
    
    <sect2>
      <title>Complex boolean expressions</title>
    
    <para>
    To construct complex boolean expressions, use the BooleanBuilder class. 
    It extends EBoolean and can be used in cascaded form : 
    </para>
    
    <programlisting language="java"><![CDATA[
public List<Customer> getCustomer(String... names){
    QCustomer customer = QCustomer.customer;    
    HibernateQuery qry = new HibernateQuery(session).from(customer);    
    BooleanBuilder builder = new BoolenBuilder();
    for (String name : names){
        builder.or(customer.name.eq(name));
    }
    qry.where(builder); // customer.name eq name1 OR customer.name eq name2 OR ...  
    return qry.list(customer);
}
]]></programlisting>    
    
    </sect2>
    
    <sect2>
      <title>Case expressions</title>
      
    <para>To construct case-when-then-else expressions use the CaseBuilder class like this : </para>  
    
<programlisting language="java"><![CDATA[    
QCustomer customer = QCustomer.customer;    
Expr<String> cases = new CaseBuilder()
    .when(customer.annualSpending.gt(10000)).then("Premier")
    .when(customer.annualSpending.gt(5000)).then("Gold")
    .when(customer.annualSpending.gt(2000)).then("Silver")
    .otherwise("Bronze");
// The cases expression can now be used in a projection or condition        
]]></programlisting>     
    
    <para>For case expressions with equals-operations use the following simpler form instead :</para>
    
<programlisting language="java"><![CDATA[    
QCustomer customer = QCustomer.customer;    
Expr<String> cases = customer.annualSpending
    .when(10000).then("Premier")
    .when(5000).then("Gold")
    .when(2000).then("Silver")
    .otherwise("Bronze");
// The cases expression can now be used in a projection or condition        
]]></programlisting>         
      
    <para>Case expressions are not yet supported in JDOQL.</para>  
      
    </sect2>
    
    </sect1>    
    
    <sect1 id="paths">
      <title>Path initialization</title>
    
      <para>
      By default Querydsl intializes only direct reference properties. In cases where longer initialization paths
      are required, these have to be annotated in the domain types via com.mysema.query.annotations.QueryInit usage.
      QueryInit is used on properties where deep initializations are needed. The following example demonstrates the
      usage.       
      </para>
      
      <programlisting language="java"><![CDATA[
@Entity      
class Event {
    @QueryInit("customer")
    Account account;
}      

@Entity
class Account{
    Customer customer;    
}

@Entity
class Customer{
    String name;
    // ...
}
]]></programlisting>      
    
    <para>
    This example enforces the initialization of the account.customer path, when an Event path is initialized
    as a root path / variable. The path initialization format supports wildcards as well, e.g. "customer.*" or just "*".
    </para>
    
    <para>
    The declarative path initialization replaces the manual one, which required the entity fields to be nonfinal. The
    declarative format has the benefit to be applied to all top level instances of a Query type and to enable the usage
    of final entity fields. 
    </para>
    
    </sect1>
    
    <sect1 id="custom_types">
      <title>Custom type mappings</title>
      
      <para>
      Custom type mappings can be used on properties to override the derived Path type. This can be useful in cases where
      comparison and String operations should be blocked on certain String paths or Date / Time support for custom
      types needs to be added. Support for Date / Time types of the Joda time API and JDK (java.util.Date, Calendar and subtypes) 
      is built in, but other APIs might need to be supported using this feature.
      </para>
      
      <para>The following example demonstrates the usage :</para>
      
      <programlisting language="java"><![CDATA[
@Entity      
public class MyEntity{      
    @QueryType(PropertyType.SIMPLE)
    public String stringAsSimple;
        
    @QueryType(PropertyType.COMPARABLE)
    public String stringAsComparable;
        
    @QueryType(PropertyType.NONE)
    public String stringNotInQuerydsl;    
}        
]]></programlisting>          
    
      <para>The value PropertyType.NONE can be used to skip a property in the Querydsl query type generation. This case is different
      from @Transient or @QueryTransient annotated properties, where properties are not persisted. PropertyType.NONE just omits the
      property from the Querydsl query type.</para>
    
    </sect1>
    
    <sect1 id="type_inheritance">
    
      <title>Inheritance in Querydsl types</title>
      
      <para>
      To avoid a generic signature in Querydsl query types the type hierarchies are flattened. The result is that
      all generated query types are direct sublcasses of com.mysema.query.types.path.PEntity and cannot be directly cast
      to their Querydsl supertypes.
      </para>
      
      <para>
      Instead of a direct Java cast, the supertype reference is accessible via the _super field. A _super-field is available
      in all query types with a single supertype :
      </para>
      
      <programlisting language="java"><![CDATA[
// from Account
QAccount extends PEntity<Account>{
    // ...
}

// from BankAccount extends Account
QBankAccount extends PEntity<BankAccount>{

    public final QAccount _super = new QAccount(this);
    
    // ...
}            
]]></programlisting>      
    
    <para>To cast from a supertype to a subtype you can use the as-method of the PEntity class :</para>
    
    <programlisting language="java"><![CDATA[
QAccount account = new QAccount("account");
QBankAccount bankAccount = account.as(QBankAccount.class);    
]]></programlisting>    
    
    </sect1>
    
    <sect1 id="alias">

  <title>Alias usage</title>

  <para>
    In cases where code generation is not an option, alias objects
    can be used as path references for expression construction.
  </para>

  <para>
    The following examples demonstrate how alias objects can be used
    as replacements for expressions based on generated types.
  </para>

  <para>
    At first an example query with APT generated domain types :
  </para>

  <programlisting language="java">
QCat cat = new QCat("cat");
for (String name : from(cat,cats)
  .where(cat.kittens.size().gt(0))
  .iterate(cat.name)){
    System.out.println(name);
}
  </programlisting>

  <para>
    And now with an alias instance for the Cat class. The call
    "c.getKittens()" inside the dollar-method is internally transformed
    into the property path c.kittens.
  </para>

  <programlisting language="java">
Cat c = alias(Cat.class, "cat");
for (String name : from($(c),cats)
  .where($(c.getKittens()).size().gt(0))
  .iterate($(c.getName()))){
    System.out.println(name);
}
  </programlisting>

  <para>
    To use the alias functionality in your code, add the following two
    imports
  </para>

  <programlisting language="java">
import static com.mysema.query.alias.Alias.$;
import static com.mysema.query.alias.Alias.alias;
  </programlisting>

  <para>
    The following example is a variation of the previous, where the access to
    the list size happens inside the dollar-method invocation.
  </para>

  <programlisting language="java">
Cat c = alias(Cat.class, "cat");
for (String name : from($(c),cats)
  .where($(c.getKittens().size()).gt(0))
  .iterate($(c.getName()))){
    System.out.println(name);
}
  </programlisting>

  <para>
    All non-primitive and non-String typed properties of aliases are aliases
    themselves. So you may cascade method calls until you hit a
    primitive or String type in the dollar-method scope.
    e.g.
  </para>

  <programlisting language="java">
$(c.getMate().getName())
  </programlisting>

  <para>
    is transformed into *c.mate.name* internally, but
  </para>

  <programlisting language="java">
$(c.getMate().getName().toLowerCase())
  </programlisting>

  <para>
    is not transformed properly, since the toLowerCase() invocation is not
    tracked.
  </para>

  <para>
    Note also that you may only invoke getters, size(), contains(Object) and
    get(int) on alias types. All other invocations throw exceptions.
  </para>
    
    
    </sect1>
    
    
            
</chapter>    