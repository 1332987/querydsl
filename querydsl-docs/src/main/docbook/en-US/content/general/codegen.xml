<sect1>

  <title>Code generation</title>

  <para>The Java 6 APT annotation processing functionality is used in Querydsl for code
    generation in the JPA, JDO and Mongodb modules. For cases where annotated Java sources
    are not available, such as the usage of a different JVM
    language such as Scala or Groovy or annotation addition via bytecode manipulation the
    <code>GenericExporter</code> class can be used to scan the classpath for annotated classes and
    generate query types for them.
  </para>

  <para>GenericExporter can be used directly or via the querydsl-maven-plugin.</para>

  <sect2>

    <title>Direct usage</title>

    <para>To make GenericExporter available add a dependency to the querydsl-codegen
      module to your project, or to be more precise
      <code>com.mysema.querydsl:querydsl-codegen:${querydsl.version}</code>.
    </para>

    <para>Below is an example for JPA</para>

    <programlisting language="java"><![CDATA[    		
GenericExporter exporter = new GenericExporter();
exporter.setKeywords(Keywords.JPA);
exporter.setEntityAnnotation(Entity.class);
exporter.setEmbeddableAnnotation(Embeddable.class);
exporter.setEmbeddedAnnotation(Embedded.class);        
exporter.setSupertypeAnnotation(MappedSuperclass.class);
exporter.setSkipAnnotation(Transient.class);
exporter.setTargetFolder(new File("target/generated-sources/java"));
exporter.export(DomainClass.class.getPackage());    	
]]></programlisting>

    <para>This will export all the JPA annotated classes in the package of the DomainClass
      class and subpackages to the target/generated-sources/java directory.
    </para>

  </sect2>

  <sect2>

    <title>Usage via Maven</title>

    <para>The goals generic-export, jpa-export and jdo-export of the querydsl-maven-plugin
      can be used for GenericExporter usage via Maven.
    </para>

    <para>Here is an example for JPA annotated classes</para>

    <programlisting language="xml"><![CDATA[    		
<plugin>
  <groupId>com.mysema.querydsl</groupId>
  <artifactId>querydsl-maven-plugin</artifactId>
  <version>${querydsl.version}</version>  
  <executions>
    <execution>    
      <goals>
        <goal>jpa-export</goal>
      </goals>
      <configuration>
        <targetFolder>target/generated-sources/java</targetFolder>
        <packages>
          <package>com.example.domain</package>
        </packages>
      </configuration>      
    </execution>
  </executions>
</plugin>    		
]]></programlisting>

    <para>This will export the JPA annotated classes of the <code>com.example.domain</code> package and
      subpackages to the target/generated-sources/java directory.
    </para>

    <para>If you need Scala output of the classes, use a variant of the following
      configuration</para>

    <programlisting language="xml"><![CDATA[    					
<plugin>
  <groupId>com.mysema.querydsl</groupId>
  <artifactId>querydsl-maven-plugin</artifactId>
  <version>${querydsl.version}</version>  
  <dependencies>
    <dependency>
      <groupId>com.mysema.querydsl</groupId>
      <artifactId>querydsl-scala</artifactId>
      <version>${project.version}</version>
    </dependency>
    <dependency>
      <groupId>org.scala-lang</groupId>
      <artifactId>scala-library</artifactId>
      <version>${scala.version}</version>
    </dependency>
  </dependencies>
  <executions>
    <execution>
      <goals>
        <goal>jpa-export</goal>
      </goals>
      <configuration>
        <targetFolder>target/generated-sources/scala</targetFolder>
        <scala>true</scala>
        <packages>
          <package>com.example.domain</package>
        </packages>       
      </configuration>
    </execution>
  </executions>
</plugin>    			
]]></programlisting>

  </sect2>

  <sect2>
    <title>Configuration</title>

    <sect3>
      <title>Path initialization</title>

      <para>
        By default Querydsl initializes only direct reference properties. In cases where
        longer initialization paths are required, these have to be annotated in the domain
        types via 
         <code>com.mysema.query.annotations.QueryInit</code>
        annotations. QueryInit is used on properties where deep initializations are
        needed. The following example demonstrates the usage.
      </para>

      <programlisting language="java"><![CDATA[
@Entity      
class Event {
    @QueryInit("customer")
    Account account;
}      

@Entity
class Account{
    Customer customer;    
}

@Entity
class Customer{
    String name;
    // ...
}
]]></programlisting>

      <para>
        This example enforces the initialization of the account.customer path, when an
        Event path is initialized as a root path / variable. The path initialization
        format supports wildcards as well, e.g. "customer.*" or just "*".
      </para>

      <para>
        The automatic path initialization replaces the manual one, which
        required the entity fields to be non-final. The declarative format has the benefit 
        to be applied to all top level instances of a Query type and to enable the usage 
        of final entity fields.
      </para>

      <para>
        Automatic path initialization is the preferred initialization strategy, but
        manual initialization can be activated via the Config annotation, which is
        described below.
      </para>

    </sect3>

    <sect3>
      <title>Customization of serialization</title>

      <para>
        The serialization of Querydsl can be customized via Config annotations on
        packages and types. They customize the serialization of the annotated package or type.
      </para>

      <para>
        The serialization options are
        <emphasis>entityAccessors</emphasis>
        to generate accessor methods for entity paths instead of public final fields (default : false),
        <emphasis>listAccessors</emphasis>
        to generate listProperty(int index) style methods (default : false),
        <emphasis>mapAccessors</emphasis>
        to generate mapProperty(Key key) style accessor methods (default : false) and
        <emphasis>createDefaultVariable</emphasis>
        to generate the default variable (default : true).
      </para>

      <para>Below are some examples.</para>

      <para>Customization of Entity type serialization :</para>

      <programlisting language="java"><![CDATA[
@Config(entityAccessors=true)
@Entity
public class UserÂ {
    //...
}     
]]></programlisting>

      <para>Customization of package content :</para>

      <programlisting language="java"><![CDATA[
@Config(listAccessors=true)
package com.mysema.query.domain.rel;

import com.mysema.query.annotations.Config;
]]></programlisting>

    <!-- TODO table for options ? -->

      <para>
        If you want to customize the serializer configuration globally,
        you can do this via
        the APT options
        <emphasis>querydsl.entityAccessors</emphasis>
        to enable reference field accessors,
        <emphasis>querydsl.listAccessors</emphasis>
        to enable accessors for direct indexed list access,
        <emphasis>querydsl.mapAccessors</emphasis>
        to enable accessors for direct key based map access,
        <emphasis>querydsl.prefix</emphasis>
        to override the prefix for query types(default: Q),
        <emphasis>querydsl.suffix</emphasis>
        to set a suffix for query types,
        <emphasis>querydsl.packageSuffix</emphasis>
        to set a suffix for query type packages,
        <emphasis>querydsl.createDefaultVariable</emphasis>
        to set whether default variables are created.
      </para>

      <para>Using the Maven APT plugin this works for example like this:
      </para>

      <programlisting language="xml"><![CDATA[
<project>
  <build>
  <plugins>
    ...
    <plugin>
      <groupId>com.mysema.maven</groupId>
      <artifactId>apt-maven-plugin</artifactId>
      <version>1.0.9</version>
      <executions>
        <execution>
          <goals>
            <goal>process</goal>
          </goals>
          <configuration>
            <outputDirectory>target/generated-sources/java</outputDirectory>
            <processor>com.mysema.query.apt.jpa.JPAAnnotationProcessor</processor>
            <options>
              <querydsl.entityAccessors>true</querydsl.entityAccessors>
            </options>          
          </configuration>
        </execution>
      </executions>
    </plugin>
    ...
  </plugins>
  </build>
</project>
]]></programlisting>


    </sect3>

    <sect3 id="custom_types">
      <title>Custom type mappings</title>

      <para>
        Custom type mappings can be used on properties to override the derived Path
        type. This can be useful for example in cases where comparison and String operations should
        be blocked on certain String paths or Date / Time support for
        custom types needs to be added. Support for Date / Time types of the Joda time API
        and JDK (java.util.Date, Calendar and subtypes) is built in, but other APIs might need 
        to be supported using this feature.
      </para>

      <para>The following example demonstrates the usage :</para>

      <programlisting language="java"><![CDATA[
@Entity      
public class MyEntity{      
    @QueryType(PropertyType.SIMPLE)
    public String stringAsSimple;
        
    @QueryType(PropertyType.COMPARABLE)
    public String stringAsComparable;
        
    @QueryType(PropertyType.NONE)
    public String stringNotInQuerydsl;    
}        
]]></programlisting>

      <para>The value <code>PropertyType.NONE</code> can be used to skip a property in the 
        query type generation. This case is different from @Transient or @QueryTransient
        annotated properties, where properties are not persisted. PropertyType.NONE just
        omits the property from the Querydsl query type.
      </para>

    </sect3>

    <sect3>
      <title>Delegate methods</title>

      <para>To declare a static method as a delegate method add the QueryDelegate
        annotation with the corresponding domain type as a value and provide a method
        signature that takes the corresponding Querydsl query type as the first argument.
      </para>


      <para>Here is a simple example from a unit test: </para>

      <programlisting language="java"><![CDATA[   
@QueryEntity
public static class User{
       
    String name;
       
    User manager;
       
}
]]></programlisting>

<programlisting language="java"><![CDATA[   
@QueryDelegate(User.class)
public static BooleanPath isManagedBy(QUser user, User other){
    return user.manager.eq(other);
}   
]]></programlisting>

      <para>And the generated methods in the QUser query type :</para>

      <programlisting language="java"><![CDATA[   
public BooleanPath isManagedBy(QUser other) {
    return com.mysema.query.domain.DelegateTest.isManagedBy(this, other);
}
    
]]></programlisting>

      <para>Delegate methods can also be used to extend built-in types.
        Here are some examples
      </para>

      <programlisting language="java"><![CDATA[       
public class QueryExtensions {

    @QueryDelegate(Date.class)
    public static BooleanExpression inPeriod(DatePath<Date> date, Pair<Date,Date> period){
        return date.goe(period.getFirst()).and(date.loe(period.getSecond()));
    }

    @QueryDelegate(Timestamp.class)
    public static BooleanExpression inDatePeriod(DateTimePath<Timestamp> timestamp, Pair<Date,Date> period){
        Timestamp first = new Timestamp(DateUtils.truncate(period.getFirst(), Calendar.DAY_OF_MONTH).getTime());
        Calendar second = Calendar.getInstance();
        second.setTime(DateUtils.truncate(period.getSecond(), Calendar.DAY_OF_MONTH));
        second.add(1, Calendar.DAY_OF_MONTH);
        return timestamp.goe(first).and(timestamp.lt(new Timestamp(second.getTimeInMillis())));
    }
    
}    
]]></programlisting>

      <para>When delegate methods are declared for builtin types then subclasses with the
        proper delegate method usages are created :
      </para>

      <programlisting language="java"><![CDATA[      
public class QDate extends DatePath<java.sql.Date> {

    public QDate(BeanPath<? extends java.sql.Date> entity) {
        super(entity.getType(), entity.getMetadata());
    }

    public QDate(PathMetadata<?> metadata) {
        super(java.sql.Date.class, metadata);
    }

    public BooleanExpression inPeriod(com.mysema.commons.lang.Pair<java.sql.Date, java.sql.Date> period) {
        return QueryExtensions.inPeriod(this, period);
    }

}

public class QTimestamp extends DateTimePath<java.sql.Timestamp> {

    public QTimestamp(BeanPath<? extends java.sql.Timestamp> entity) {
        super(entity.getType(), entity.getMetadata());
    }

    public QTimestamp(PathMetadata<?> metadata) {
        super(java.sql.Timestamp.class, metadata);
    }

    public BooleanExpression inDatePeriod(com.mysema.commons.lang.Pair<java.sql.Date, java.sql.Date> period) {
        return QueryExtensions.inDatePeriod(this, period);
    }

}
]]></programlisting>

    </sect3>

    <sect3>

      <title>Query type generation for non annotated types</title>

      <para>
        It is possible to create Querydsl query types for non annotated types by
        creating <code>@QueryEntities</code> annotations. Just place a QueryEntities annotation into a
        package of your choice and the classes to mirrored in the value attribute.
      </para>

      <para>
        To actually create the types use the
        <code>com.mysema.query.apt.QuerydslAnnotationProcessor</code>
        .
        In Maven you do it like this :
      </para>

      <programlisting language="xml"><![CDATA[
<project>
  <build>
  <plugins>
    ...
    <plugin>
      <groupId>com.mysema.maven</groupId>
      <artifactId>apt-maven-plugin</artifactId>
      <version>1.0.9</version>
      <executions>
        <execution>
          <goals>
            <goal>process</goal>
          </goals>
          <configuration>
            <outputDirectory>target/generated-sources/java</outputDirectory>
            <processor>com.mysema.query.apt.QuerydslAnnotationProcessor</processor>
          </configuration>
        </execution>
      </executions>
    </plugin>
    ...
  </plugins>
  </build>
</project>
]]></programlisting>

    </sect3>

  </sect2>

</sect1>    